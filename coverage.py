import numpy as np
import pandas as pd


#this script takes coverage files generated by DNAnexus and looks at every nucleotide in the genome
#and take 100 nucleotides upstream of that single nucleotide and 100 nucleoties downstream of that
#single nucleotide. Calculates the median for each 100 nucletotide sequence. Then calculates
#a ratio of this windows. This script is looking for potential terminators. The script
#does have a function for normalizing the data and it scales to TPM

def get_chromosome_length(cov_file_path):
    max_coord = 0
    with open(cov_file_path, 'r') as file:
        for line in file:
            parts = line.strip().split('\t')
            pos = int(parts[1])  # assuming the position is in the second column
            if pos > max_coord:
                max_coord = pos
    return max_coord


def load_raw_coverage(cov_file_path, chromosome_length):
    # Initialize an array to hold coverage values
    coverage = np.zeros(chromosome_length)

    # Open the .cov file and read line by line
    with open(cov_file_path, 'r') as file:
        for line in file:
            parts = line.strip().split('\t')
            pos = int(parts[1]) - 1  # Convert 1-based position to 0-based index
            cov_value = float(parts[2])
            if 0 <= pos < chromosome_length:
                coverage[pos] = cov_value
    
    return coverage
def load_and_normalize_to_TPM(cov_file_path, chromosome_length):
    coverage = load_raw_coverage(cov_file_path, chromosome_length)
    
    # Calculate total read counts (coverage sum)
    total_reads = np.sum(coverage)
    
    # Normalize coverage by total read counts to get coverage per read count
    normalized_coverage = coverage / total_reads if total_reads > 0 else coverage
    
    # Scale to TPM (Transcripts Per Million)
    tpm_normalized_coverage = normalized_coverage * 1e6
    
    return tpm_normalized_coverage


def calculate_window_medians(coverage, window_size):
    # Initialize arrays to hold the medians
    upstream_medians = np.zeros(len(coverage))
    downstream_medians = np.zeros(len(coverage))
    
    # Calculate the medians using a rolling window approach
    for i in range(window_size, len(coverage) - window_size):
        upstream_window = coverage[i-window_size:i]
        downstream_window = coverage[i+1:i+1+window_size]
        upstream_medians[i] = np.median(upstream_window)
        downstream_medians[i] = np.median(downstream_window)
    
    # For positions where a full window is not possible, the median is set to NaN
    upstream_medians[:window_size] = np.nan
    downstream_medians[-window_size:] = np.nan
    
    return upstream_medians, downstream_medians




def create_ratio_df(upstream_medians, downstream_medians, strand, chromosome_length, min_non_zero_value=0.002):
    # Use min_non_zero_value instead of a small epsilon for the ratio calculation
    if strand == 'Forward':
        # For forward strand, calculate the ratio by dividing upstream by the downstream adjusting the denominator
        ratios = upstream_medians / np.maximum(downstream_medians, min_non_zero_value)
    elif strand == 'Reverse':
        # For reverse strand, calculate the ratio by dividing the downstream by the upstream, adjusting the denominator
        ratios = downstream_medians / np.maximum(upstream_medians, min_non_zero_value)
    else:
        raise ValueError("Strand must be 'Forward' or 'Reverse'")

    data = {
        'Coord': np.arange(1, chromosome_length + 1),
        f'{strand}_Upstream_Median': upstream_medians,
        f'{strand}_Downstream_Median': downstream_medians,
        f'{strand}_Ratio': ratios
    }
    df = pd.DataFrame(data)
    df.fillna(0, inplace=True)  # Fill NaN values resulting from the rolling window at the edges with zeros
    return df



# forward and reverse strand coverage files
forward_cov_path = '243_235_236_1325_BCM_m14_M30_all_files/243_235_236_1325_BCM_m14_M30_fwd.cov'
reverse_cov_path = '243_235_236_1325_BCM_m14_M30_all_files/243_235_236_1325_BCM_m14_M30_rev.cov'
chromosome_name = 'NC_000913.2'
chromosome_length = get_chromosome_length(forward_cov_path)
window_size = 100


forward_coverage = load_and_normalize_to_TPM(forward_cov_path, chromosome_length)
reverse_coverage = load_and_normalize_to_TPM(reverse_cov_path, chromosome_length)

forward_upstream_medians, forward_downstream_medians = calculate_window_medians(forward_coverage, window_size)
reverse_upstream_medians, reverse_downstream_medians = calculate_window_medians(reverse_coverage, window_size)

forward_df = create_ratio_df(forward_upstream_medians, forward_downstream_medians, 'Forward', chromosome_length)
reverse_df = create_ratio_df(reverse_upstream_medians, reverse_downstream_medians, 'Reverse', chromosome_length)

# Save to files as needed
forward_df.to_csv('243_235_236_1325_BCM_m14_M30_fwd_coverage.txt', sep='\t', index=False)
reverse_df.to_csv('243_235_236_1325_BCM_m14_M30_rev_coverage.txt', sep='\t', index=False)

print("The coverage tables have been saved.")